<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async Benchmark UI</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 3. Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Custom spinner animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root"></div>

    <!-- 4. Our React Application -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Configuration ---
        const API_BASE_URL = 'http://localhost:8000/api'; // Backend URL
        const POLLING_INTERVAL = 10000; // Poll every 10 seconds

        // --- Main App Component ---
        function App() {
            const [selectedFilter, setSelectedFilter] = useState('grayscale');
            const [isLoading, setIsLoading] = useState(false);
            const [message, setMessage] = useState('Select a filter and start the benchmark.');
            const [currentJobId, setCurrentJobId] = useState(null);
            
            // Refs for objects that shouldn't trigger re-renders
            const pollingIntervalRef = useRef(null);
            const chartRef = useRef(null); // Ref to the canvas element
            const chartInstanceRef = useRef(null); // Ref to the Chart.js instance

            // Cleanup effect to stop polling if component unmounts
            useEffect(() => {
                return () => {
                    if (pollingIntervalRef.current) {
                        clearInterval(pollingIntervalRef.current);
                    }
                };
            }, []);

            /**
             * Clears any existing polling interval and chart.
             */
            function stopAndClear() {
                if (pollingIntervalRef.current) {
                    clearInterval(pollingIntervalRef.current);
                    pollingIntervalRef.current = null;
                }
                if (chartInstanceRef.current) {
                    chartInstanceRef.current.destroy();
                    chartInstanceRef.current = null;
                }
                setIsLoading(false);
            }

            /**
             * Workflow Step 1: Start the benchmark job
             */
            async function handleStartBenchmark() {
                stopAndClear();
                setIsLoading(true);
                setMessage('Starting job...');

                try {
                    const response = await fetch(`${API_BASE_URL}/benchmark/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filter_type: selectedFilter }),
                    });

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.statusText}`);
                    }

                    const data = await response.json();
                    setCurrentJobId(data.job_id);
                    setMessage(`Job started (ID: ${data.job_id}). Status: ${data.status}`);

                    // Start polling
                    pollingIntervalRef.current = setInterval(() => {
                        pollStatus(data.job_id);
                    }, POLLING_INTERVAL); // Use the 10-second interval

                } catch (error) {
                    console.error('Failed to start benchmark:', error);
                    setMessage(`Error starting job: ${error.message}`);
                    setIsLoading(false);
                }
            }

            /**
             * Workflow Step 2: Poll for job status
             */
            async function pollStatus(jobId) {
                if (!jobId) return;

                console.log(`[${jobId}] Polling status...`); // Added for debugging
                try {
                    const response = await fetch(`${API_BASE_URL}/benchmark/status/${jobId}`);
                    
                    if (!response.ok) {
                        // 404 might mean job is gone, stop polling
                        if (response.status === 404) {
                             throw new Error('Job not found (404). Stopping poll.');
                        }
                        throw new Error(`Polling error: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log(`[${jobId}] Status: ${data.status}`); // Added for debugging

                    switch (data.status) {
                        case 'pending':
                        case 'processing':
                            setMessage(`Status: ${data.status}... (Next check in 10s)`);
                            break;
                        
                        case 'completed':
                            setMessage('Job completed! Fetching results...');
                            stopAndClear();
                            fetchResults(jobId);
                            break;
                        
                        case 'failed':
                            setMessage(`Error: Job failed. (${data.error || 'Unknown error'})`);
                            stopAndClear();
                            break;
                        
                        default:
                            setMessage(`Unknown status: ${data.status}`);
                            stopAndClear();
                    }
                } catch (error) {
                    console.error('Polling failed:', error);
                    setMessage(`Polling failed: ${error.message}`);
                    stopAndClear();
                }
            }

            /**
             * Workflow Step 3: Fetch final results and draw chart
             */
            async function fetchResults(jobId) {
                setIsLoading(true); // Show loader while fetching/drawing
                try {
                    const response = await fetch(`${API_BASE_URL}/benchmark/result/${jobId}`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch results: ${response.statusText}`);
                    }

                    const data = await response.json();
                    
                    // Format data for Chart.js
                    const labels = ['CUDA', 'OpenMP', 'MPI'];
                    
                    // *** FIX: Changed keys from total_processing_time_ms to total_processing_time ***
                    const times = [
                        data.cuda_results.total_processing_time,
                        data.openmp_results.total_processing_time,
                        data.mpi_results.total_processing_time,
                    ];

                    drawChart(labels, times);
                    // Round the time to 2 decimal places for display
                    const displayTime = parseFloat(times[0]).toFixed(2);
                    setMessage(`Benchmark complete. Total time for CUDA: ${displayTime}ms.`);

                } catch (error) {
                    console.error('Failed to fetch results:', error);
                    setMessage(`Error fetching results: ${error.message}`);
                } finally {
                    setIsLoading(false);
                }
            }

            /**
             * Helper: Draws the bar chart
             */
            function drawChart(labels, data) {
                if (chartInstanceRef.current) {
                    chartInstanceRef.current.destroy();
                }
                
                const ctx = chartRef.current.getContext('2d');
                chartInstanceRef.current = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Total Processing Time (ms)',
                            data: data,
                            backgroundColor: [
                                'rgba(118, 185, 0, 0.6)', // CUDA (Nvidia Green)
                                'rgba(54, 162, 235, 0.6)', // OpenMP (Blue)
                                'rgba(255, 99, 132, 0.6)', // MPI (Red)
                            ],
                            borderColor: [
                                'rgba(118, 185, 0, 1)',
                                'rgba(54, 162, 235, 1)',
                                'rgba(255, 99, 132, 1)',
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        plugins: {
                            title: {
                                display: true,
                                text: `Benchmark Results for '${selectedFilter}' Filter (Lower is Better)`,
                                font: { size: 18 }
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Time (milliseconds)'
                                }
                            }
                        },
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            }

            return (
                <div className="container mx-auto p-4 max-w-4xl">
                    <div className="bg-white rounded-lg shadow-xl p-6">
                        <h1 className="text-3xl font-bold text-gray-800 mb-4">Async Benchmark Dashboard (v0.2)</h1>
                        
                        {/* 1. Controls */}
                        <div className="flex flex-col sm:flex-row sm:items-center gap-4 p-4 bg-gray-50 rounded-lg border">
                            <div className="flex-1">
                                <label htmlFor="filter" className="block text-sm font-medium text-gray-700 mb-1">Filter Type</label>
                                <select
                                    id="filter"
                                    value={selectedFilter}
                                    onChange={(e) => setSelectedFilter(e.target.value)}
                                    disabled={isLoading}
                                    className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
                                >
                                    <option value="grayscale">Grayscale</option>
                                    <option value="blur">Blur</option>
                                    <option value="sharpen">Sharpen</option>
                                    <option value="edge_detect">Edge Detect</option>
                                </select>
                            </div>
                            <div className="sm:mt-5">
                                <button
                                    onClick={handleStartBenchmark}
                                    disabled={isLoading}
                                    className={`w-full sm:w-auto px-6 py-2.5 font-semibold text-white rounded-md shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all ${
                                        isLoading
                                            ? 'bg-gray-400 cursor-not-allowed'
                                            : 'bg-blue-600 hover:bg-blue-700 focus:ring-blue-500'
                                    }`}
                                >
                                    {isLoading ? 'Processing...' : 'Start Benchmark'}
                                </button>
                            </div>
                        </div>
                        
                        {/* 2. Status & Results */}
                        <div className="mt-6 min-h-[300px]">
                            <h2 className="text-xl font-semibold text-gray-700">Status</h2>
                            <div className="p-4 mt-2 bg-gray-100 rounded-md text-gray-800 font-mono text-sm break-all">
                                {message}
                            </div>
                            
                            <div className="mt-6 relative h-96">
                                {isLoading && !chartInstanceRef.current && (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 z-10">
                                        <div className="spinner"></div>
                                        <span className="mt-3 font-semibold text-gray-600">Job is running...</span>
                                    </div>
                                )}
                                <canvas ref={chartRef} id="myChart"></canvas>
                            </div>
                        </div>

                    </div>
                </div>
            );
        }

        // --- 5. Mount the App ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

